#requires -version 2


function Invoke-WorkerWmiExecCommand
{
    param
    (
        #Parameter assignment
        [Parameter(Mandatory = $False)]
        [string]$User,
        [Parameter(Mandatory = $False)] 
        [string]$Pass,
        [Parameter(Mandatory = $False)] 
        [string[]]$Targets = ".",
        [Parameter(Mandatory = $True)] 
        [string]$Command
    )

    if($User -and $Pass)
    {
        # This block of code is executed when starting a process on a remote machine via wmi
        $password = ConvertTo-SecureString $Pass -asplaintext -force 
        $cred = New-Object -Typename System.Management.Automation.PSCredential -argumentlist $User,$password

        Invoke-WmiMethod -class win32_process -name create -Argumentlist $Command -Credential $cred -Computername $Targets
    }

    else
    {
        # If this area of code is invoked, it runs the command on the same machine the script is loaded
        Invoke-WmiMethod -class win32_process -name create -Argumentlist $Command
    }
}

function Invoke-WorkerWmiKillProcess
{
    param
    (
        #Parameter assignment
        [Parameter(Mandatory = $False)]
        [string]$User,
        [Parameter(Mandatory = $False)] 
        [string]$Pass,
        [Parameter(Mandatory = $False)] 
        [string[]]$Targets = ".",
        [Parameter(Mandatory = $False)] 
        [string]$ProcName,
        [Parameter(Mandatory = $False)] 
        [string]$ProcID
    )

    if($User -and $Pass)
    {
        # This block of code is executed when starting a process on a remote machine via wmi
        $password = ConvertTo-SecureString $Pass -asplaintext -force 
        $cred = New-Object -Typename System.Management.Automation.PSCredential -argumentlist $User,$password

        if($ProcessName)
        {
            ForEach($computer in $TARGETS)
            {
                Get-WmiObject -Class win32_Process -Credential $cred -Computername $computer -Filter "name = '$ProcName'" | ForEach-Object { $_.Terminate() }
            }
        }

        elseif($ProcessID)
        {
            ForEach($computer in $TARGETS)
            {
                Get-WmiObject -Class win32_Process -Credential $cred -Computername $computer -Filter "ProcessID = '$ProcID'" | ForEach-Object { $_.Terminate() }
            }
        }

        else
        {
            Write-Verbose "You didn't provide a valid action to take! This script uses processid or processname!"
        }
    }

    else
    {
        if($ProcessName)
        {
            Get-WmiObject -Class win32_Process -Filter "name = '$ProcName'" | ForEach-Object { $_.Terminate() }
        }

        elseif($ProcessID)
        {
            Get-WmiObject -Class win32_Process -Filter "ProcessID = '$ProcID'" | ForEach-Object { $_.Terminate() }
        }

        else
        {
            Write-Verbose "You didn't provide a valid action to take! This script uses processid or processname!"
        }
    }
}


function Invoke-WmiExecCommand
{
    <#
    .SYNOPSIS
    This function is used to run a command/start a process on either the local or a remote machine.  This requires local admin access wherever the command is to be executed.

    .DESCRIPTION
    This function is used to run a command/start a process on either the local or a remote machine.  This can be used to simply ping a machine, run an executable, or run any command in the target's system path.

    .PARAMETER User
    Specify a username  Default is the current user context.

    .PARAMETER Pass
    Specify the password for the appropriate user.

    .PARAMETER TARGETs
    Host or array of hosts to target. Can be a hostname, IP address, or FQDN. Default is set to localhost.

    .PARAMETER Command
    Specify the command that is executed on the targeted machine.

    .EXAMPLE
    > Invoke-WmiExecCommand -Command ping -n 4 192.168.1.1
    This pings the system at 192.168.1.1 with 4 ping requests from the local system

    .EXAMPLE
    > Invoke-WmiExecCommand -Command notepad.exe -User Chris -Pass password -Target chrispc
    This command authenticates to chrispc and starts notepad.exe

    .LINK
    https://github.com/xorrior/RandomPS-Scripts
    
    #>

    param
    (
        #Parameter assignment
        [Parameter(Mandatory = $False)]
        [string]$User,
        [Parameter(Mandatory = $False)] 
        [string]$Pass,
        [Parameter(Mandatory = $False)] 
        [string[]]$Targets = ".",
        [Parameter(Mandatory = $True)] 
        [string]$Command
    )

    Begin
    {
        #Check if the TARGETS parameter was passed through the pipeline. Set the usedParameter variable to true. 
        $usedParameter = $False 
        if($PSBoundParameters.ContainsKey('TARGETS'))
        {
            $usedParameter = $True 
        }
    }

    Process
    {
        #If targets is passed via the parameter, complete function for each host. 
        if($usedParameter)
        {
            Foreach($computer in $TARGETS)
            {
                Invoke-WorkerWmiExecCommand -User "$User" -Pass "$Pass" -Targets "$computer" -Command "$Command"
            }
        }
        #Pass the value from the pipeline to the target parameter if the usedParameter variable is false.
        else
        {
          Invoke-WorkerWmiExecCommand -Command "$Command"
        }
    }

    end{}
}


function Invoke-WMIKillProcess
{
<#
    .SYNOPSIS
    This function is used to kill a process on either the local or a remote machine via a process name or ID.  This requires local admin access wherever the command is to be executed.

    .DESCRIPTION
    This function is used to kill a process on either the local or a remote machine via a process name or ID.  This requires local admin rights.

    .PARAMETER User
    Specify a username  Default is the current user context.

    .PARAMETER Pass
    Specify the password for the appropriate user.

    .PARAMETER TARGETs
    Host or array of hosts to target. Can be a hostname, IP address, or FQDN. Default is set to localhost.

    .PARAMETER ProcessName
    Specify the name of the process that is to be killed on the targeted machine.

    .PARAMETER ProcessID
    Specify the process ID number that is to be killed on the targeted machine.

    .EXAMPLE
    > Invoke-WMIKillProcess -ProcessName notepad.exe
    This kills all processes with the name notepad.exe on the local machine

    .EXAMPLE
    > Invoke-WMIKillProcess -ProcessID 2048 -User Chris -Pass password -Target chrispc
    This command authenticates to chrispc and and attempts to kill the process with pid 2048.

    .LINK
    https://github.com/xorrior/RandomPS-Scripts
#>

    param
    (
        #Parameter assignment
        [Parameter(Mandatory = $False)] 
        [string]$User,
        [Parameter(Mandatory = $False)] 
        [string]$Pass,
        [Parameter(Mandatory = $False)] 
        [string]$ProcessName,
        [Parameter(Mandatory = $False)] 
        [string]$ProcessID,
        [Parameter(Mandatory = $False)] 
        [string[]]$TARGETS = "."
    )

    Begin
    {
        # Check if the TARGETS parameter was passed through the pipeline. Set the usedParameter variable to true. 
        $usedParameter = $False
        if($PSBoundParameters.ContainsKey('TARGETS'))
        {
            $usedParameter = $True
        }
    }

    Process
    {
        # If targets is passed via the parameter, complete function for each host
        if($usedParameter)
        {
            if($ProcessName)
            {
                ForEach($computer in $TARGETS)
                {
                    Invoke-WorkerWmiKillProcess -User "$User" -Pass "$Pass" -Targets "$computer" -ProcName $ProcessName
                }
            }

            elseif($ProcessID)
            {
                ForEach($computer in $TARGETS)
                {
                    Invoke-WorkerWmiKillProcess -User "$User" -Pass "$Pass" -Targets "$computer" -ProcID $ProcessID
                }
            }

            else
            {
                Write-Verbose "You didn't provide a valid action to take! This script uses processid or processname!"
            }
        }

        #Pass the value from the pipeline to the target parameter if the usedParameter variable is false.
        else
        {
            if($ProcessName)
            {
                ForEach($computer in $TARGETS)
                {
                    Invoke-WorkerWmiKillProcess -User "$User" -Pass "$Pass" -ProcName $ProcessName
                }
            }
            elseif($ProcessID)
            {
                ForEach($computer in $TARGETS)
                {
                    Invoke-WorkerWmiKillProcess -User "$User" -Pass "$Pass" -ProcID $ProcessID
                }
            }
            else
            {
                Write-Verbose "You didn't provide a valid action to take! This script uses processid or processname!"
            }
        }
    }

    end{}
}

function Get-RunningProcesses
{
<#
.SYNOPSIS
TBA
Some of this is from - http://blogs.technet.com/b/heyscriptingguy/archive/2009/12/10/hey-scripting-guy-december-10-2009.aspx
.DESCRIPTION
TBA
.PARAMETER TBA
.EXAMPLE
TBA
#>

    param
    (
        #Parameter assignment
        [Parameter(Mandatory = $False)] 
        [string]$User,
        [Parameter(Mandatory = $False)] 
        [string]$Pass,
        [Parameter(Mandatory = $False)] 
        [string[]]$TARGETS = "."
    )

    if($User -and $Pass)
    {
        $password = ConvertTo-SecureString $Pass -asplaintext -force 
        $cred = New-Object -Typename System.Management.Automation.PSCredential -argumentlist $User,$password
        Foreach($computer in $TARGETS)
            {
                Write-Verbose "Connecting to $computer"
                Get-WMIObject Win32_Process -Credential $cred -computername $computer | ForEach-Object { $_.ProcessName } | Sort-Object | Get-Unique
            }
    }

    else
    {
        Write-Verbose "Checking local system..."
        Get-WMIObject Win32_Process | ForEach-Object { $_.ProcessName } | Sort-Object | Get-Unique
    }
}

function Get-ProcessOwners
{
<#
.SYNOPSIS
TBA
Some of this is from - http://blogs.technet.com/b/heyscriptingguy/archive/2009/12/10/hey-scripting-guy-december-10-2009.aspx
.DESCRIPTION
TBA
.PARAMETER TBA
.EXAMPLE
TBA
#>

    param
    (
        #Parameter assignment
        [Parameter(Mandatory = $False)] 
        [string]$User,
        [Parameter(Mandatory = $False)] 
        [string]$Pass,
        [Parameter(Mandatory = $False)] 
        [string[]]$TARGETS = "."
    )

    if($User -and $Pass)
    {
        $password = ConvertTo-SecureString $Pass -asplaintext -force 
        $cred = New-Object -Typename System.Management.Automation.PSCredential -argumentlist $User,$password
        Foreach($computer in $TARGETS)
            {
                Write-Verbose "Connecting to $computer"
                Get-WMIObject Win32_Process -Credential $cred -computername $computer | ForEach-Object { $owner = $_.GetOwner(); '{0}\{1}' -f $owner.Domain, $owner.User } | Sort-Object | Get-Unique
            }
    }

    else
    {
        Write-Verbose "Checking local system..."
        Get-WMIObject Win32_Process | ForEach-Object { $owner = $_.GetOwner(); '{0}\{1}' -f $owner.Domain, $owner.User } | Sort-Object | Get-Unique
    }
}


function Query-UsersActive
{
<#
.SYNOPSIS
TBA
Some of this is from - http://www.activxperts.com/admin/scripts/wmi/powershell/0388/
.DESCRIPTION
TBA
.PARAMETER TBA
.EXAMPLE
TBA
#>

    param
    (
        #Parameter assignment
        [Parameter(Mandatory = $False)] 
        [string]$User,
        [Parameter(Mandatory = $False)] 
        [string]$Pass,
        [Parameter(Mandatory = $False)] 
        [string[]]$TARGETS = "."
    )

    if($User -and $Pass)
    {
        $password = ConvertTo-SecureString $Pass -asplaintext -force 
        $cred = New-Object -Typename System.Management.Automation.PSCredential -argumentlist $User,$password
        Foreach($computer in $TARGETS)
            {
                # Need to add in filtering here to stop if a "true" has been found for screensavers being active
                Write-Verbose "Connecting to $computer"
                [string]$ScreenshotActive = Get-RunningProcesses -User $User -Pass $Pass -Targets $Targets | Select-String ".scr"
                [string]$LoginPrompt = Get-RunningProcesses -User $User -Pass $Pass -Targets $Targets | Select-String "LogonUI.exe"

                # If either returned true, we can assume the user is not active at their desktop
                if ($ScreenshotActive -or $LoginPrompt)
                {
                    Write-Output "User is not present!"
                }
                else
                {
                    Write-Output "User is at their desktop!"
                }
            }
    }

    else
    {
        Write-Verbose "Checking local system..."
        Get-WMIObject Win32_Desktop | ForEach-Object { $_.ScreenSaverActive } | Sort-Object | Get-Unique
        Get-WMIObject Win32_Process -filter 'name = "LogonUI.exe"' | ForEach-Object { $_.ProcessName } | Sort-Object | Get-Unique
    }
}

# location for managing shares - http://windowsitpro.com/powershell/managing-file-shares-windows-powershell
# (Get-WmiObject Win32_Share -List).Create( "C:\Users\SonofFlynn\Downloads\apple", "testshare", 0 )