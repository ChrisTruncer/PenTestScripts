#requires -version 2


function Invoke-WorkerWmiExecCommand
{
    param
    (
        #Parameter assignment
        [Parameter(Mandatory = $False)]
        [string]$User,
        [Parameter(Mandatory = $False)] 
        [string]$Pass,
        [Parameter(Mandatory = $False)] 
        [string[]]$Targets = ".",
        [Parameter(Mandatory = $True)] 
        [string]$Command
    )

    if($User -and $Pass)
    {
        # This block of code is executed when starting a process on a remote machine via wmi
        $password = ConvertTo-SecureString $Pass -asplaintext -force 
        $cred = New-Object -Typename System.Management.Automation.PSCredential -argumentlist $User,$password

        Invoke-WmiMethod -class win32_process -name create -Argumentlist $Command -Credential $cred -Computername $Targets
    }

    else
    {
        # If this area of code is invoked, it runs the command on the same machine the script is loaded
        Invoke-WmiMethod -class win32_process -name create -Argumentlist $Command
    }
}

function Invoke-WorkerWmiKillProcess
{
    param
    (
        #Parameter assignment
        [Parameter(Mandatory = $False)]
        [string]$User,
        [Parameter(Mandatory = $False)] 
        [string]$Pass,
        [Parameter(Mandatory = $False)] 
        [string[]]$Targets = ".",
        [Parameter(Mandatory = $True)] 
        [string]$ProcName,
        [Parameter(Mandatory = $True)] 
        [string]$ProcID
    )

    if($User -and $Pass)
    {
        # This block of code is executed when starting a process on a remote machine via wmi
        $password = ConvertTo-SecureString $Pass -asplaintext -force 
        $cred = New-Object -Typename System.Management.Automation.PSCredential -argumentlist $User,$password

        if($ProcessName)
        {
            ForEach($computer in $TARGETS)
            {
                Get-WmiObject -Class win32_Process -Credential $cred -Computername $computer -Filter "name = '$ProcName'" | ForEach-Object { $_.Terminate() }
            }
        }

        elseif($ProcessID)
        {
            ForEach($computer in $TARGETS)
            {
                Get-WmiObject -Class win32_Process -Credential $cred -Computername $computer -Filter "ProcessID = '$ProcID'" | ForEach-Object { $_.Terminate() }
            }
        }

        else
        {
            Write-Verbose "You didn't provide a valid action to take! This script uses processid or processname!"
        }
    }

    else
    {
        if($ProcessName)
        {
            Get-WmiObject -Class win32_Process -Filter "name = '$ProcName'" | ForEach-Object { $_.Terminate() }
        }

        elseif($ProcessID)
        {
            Get-WmiObject -Class win32_Process -Filter "ProcessID = '$ProcID'" | ForEach-Object { $_.Terminate() }
        }

        else
        {
            Write-Verbose "You didn't provide a valid action to take! This script uses processid or processname!"
        }
    }
}


function Invoke-WmiExecCommand
{
    <#
    .SYNOPSIS
    This function is used to run a command/start a process on either the local or a remote machine.  This requires local admin access either wherever the command is to be executed.

    .DESCRIPTION
    This function is used to run a command/start a process on either the local or a remote machine.  This can be used to simply ping a machine, run an executable, or run any command in the target's system path.

    .PARAMETER User
    Specify a username  Default is the current user context.

    .PARAMETER Pass
    Specify the password for the appropriate user.

    .PARAMETER TARGETs
    Host or array of hosts to target. Can be a hostname, IP address, or FQDN. Default is set to localhost.

    .PARAMETER Command
    Specify the command that is executed on the targeted machine.

    .EXAMPLE
    > Invoke-WmiExecCommand -Command ping -n 4 192.168.1.1
    This pings the system at 192.168.1.1 with 4 ping requests from the local system

    .EXAMPLE
    > Invoke-WmiExecCommand -Command notepad.exe -User Chris -Pass password -Target chrispc
    This command authenticates to chrispc and starts notepad.exe

    .LINK
    https://github.com/xorrior/RandomPS-Scripts
    
    #>

    param
    (
        #Parameter assignment
        [Parameter(Mandatory = $False)]
        [string]$User,
        [Parameter(Mandatory = $False)] 
        [string]$Pass,
        [Parameter(Mandatory = $False)] 
        [string[]]$Targets = ".",
        [Parameter(Mandatory = $True)] 
        [string]$Command
    )

    Begin
    {
        #Check if the TARGETS parameter was passed through the pipeline. Set the usedParameter variable to true. 
        $usedParameter = $False 
        if($PSBoundParameters.ContainsKey('TARGETS'))
        {
            $usedParameter = $True 
        }
    }

    Process
    {
        #If targets is passed via the parameter, complete function for each host. 
        if($usedParameter)
        {
            Foreach($computer in $TARGETS)
            {
                Invoke-WorkerWmiExecCommand -User "$User" -Pass "$Pass" -Targets "$computer" -Command "$Command"
            }
        }
        #Pass the value from the pipeline to the target parameter if the usedParameter variable is false.
        else
        {
          Invoke-WorkerWmiExecCommand -Command "$Command"
        }
    }

    end{}
}


function Invoke-WMIKillProcess
{
<#
.SYNOPSIS
TBA
Some of this is from - http://blogs.technet.com/b/heyscriptingguy/archive/2009/12/10/hey-scripting-guy-december-10-2009.aspx
.DESCRIPTION
TBA
.PARAMETER TBA
.EXAMPLE
TBA
#>

    param
    (
        #Parameter assignment
        [Parameter(Mandatory = $False)] 
        [string]$User,
        [Parameter(Mandatory = $False)] 
        [string]$Pass,
        [Parameter(Mandatory = $False)] 
        [string]$ProcessName,
        [Parameter(Mandatory = $False)] 
        [string]$ProcessID,
        [Parameter(Mandatory = $False)] 
        [string[]]$TARGETS = "."
    )

    Begin
    {
        # Check if the TARGETS parameter was passed through the pipeline. Set the usedParameter variable to true. 
        $usedParameter = $False 
        if($PSBoundParameters.ContainsKey('TARGETS'))
        {
            $usedParameter = $True 
        }
    }

    Process
    {
        # If targets is passed via the parameter, complete function for each host
        if($usedParameter)
        {
            if($ProcessName)
            {
                ForEach($computer in $TARGETS)
                {
                    Invoke-WorkerWmiKillProcess -User "$User" -Pass "$Pass" -Targets "$computer" -ProcName $ProcessName
                }
            }

            elseif($ProcessID)
            {
                ForEach($computer in $TARGETS)
                {
                    Invoke-WorkerWmiKillProcess -User "$User" -Pass "$Pass" -Targets "$computer" -ProcID $ProcessID
                }
            }

            else
            {
                Write-Verbose "You didn't provide a valid action to take! This script uses processid or processname!"
            }
        }

        #Pass the value from the pipeline to the target parameter if the usedParameter variable is false.
        else
        {
            if($ProcessName)
            {
                ForEach($computer in $TARGETS)
                {
                    Invoke-WorkerWmiKillProcess -User "$User" -Pass "$Pass" -ProcName $ProcessName
                }
            }
            elseif($ProcessID)
            {
                ForEach($computer in $TARGETS)
                {
                    Invoke-WorkerWmiKillProcess -User "$User" -Pass "$Pass" -ProcID $ProcessID
                }
            }
            else
            {
                Write-Verbose "You didn't provide a valid action to take! This script uses processid or processname!"
            }
        }
    }

    end{}
}

function Get-ProcessOwners
{
<#
.SYNOPSIS
TBA
Some of this is from - http://blogs.technet.com/b/heyscriptingguy/archive/2009/12/10/hey-scripting-guy-december-10-2009.aspx
.DESCRIPTION
TBA
.PARAMETER TBA
.EXAMPLE
TBA
#>

    param
    (
        #Parameter assignment
        [Parameter(Mandatory = $False)] 
        [string]$User,
        [Parameter(Mandatory = $False)] 
        [string]$Pass,
        [Parameter(Mandatory = $False)] 
        [string[]]$TARGETS = "."
    )

    if($User -and $Pass)
    {
        $password = ConvertTo-SecureString $Pass -asplaintext -force 
        $cred = New-Object -Typename System.Management.Automation.PSCredential -argumentlist $User,$password
        Write-Host "This hit"
    }

    Invoke-WMIMethod -class win32_process -name Create -Argumentlist notepad.exe -Credential $cred -ComputerName $TARGETS

    Get-WmiObject -class win32_process -Filter "Name = 'notepad.exe'" -Credential $cred -ComputerName $TARGETS | foreach-object { $_.GetOwner().user; $_.GetOwnerSid().sid; }
    
    Get-WMIObject Win32_Process -Credential $cred -computername win7pdws1-pc | ForEach-Object { $owner = $_.GetOwner(); '{0}\{1}' -f $owner.Domain, $owner.User } | Sort-Object | Get-Unique

    # location for managing shares - http://windowsitpro.com/powershell/managing-file-shares-windows-powershell
    # (Get-WmiObject Win32_Share -List).Create( "C:\Users\SonofFlynn\Downloads\apple", "pooperscooper", 0 )
}
